<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Fabric | 简单的Coder]]></title>
  <link href="http://dlutcat.github.com/blog/categories/fabric/atom.xml" rel="self"/>
  <link href="http://dlutcat.github.com/"/>
  <updated>2012-12-17T23:25:36+08:00</updated>
  <id>http://dlutcat.github.com/</id>
  <author>
    <name><![CDATA[dlutcat]]></name>
    <email><![CDATA[pat.inside@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[多服务器管理之Fabric]]></title>
    <link href="http://dlutcat.github.com/blog/2012/11/25/duo-fu-wu-qi-guan-li-zhi-fabric/"/>
    <updated>2012-11-25T15:38:00+08:00</updated>
    <id>http://dlutcat.github.com/blog/2012/11/25/duo-fu-wu-qi-guan-li-zhi-fabric</id>
    <content type="html"><![CDATA[<h3>背景</h3>

<p>最近公司服务器从单机扩展到三机，新环境的搭建和部署也采用了新的自动化方式：<a href="http://docs.fabfile.org/en/1.5/">Fabric</a>。</p>

<h3>什么是Fabric</h3>

<p>用<a href="http://docs.fabfile.org/en/1.5/">Fabric</a>其实就是一套用Python封装了基于SSH的常见操作的库。因此，它的优势显而易见：</p>

<ol>
<li>你可以用Python代理Shell来做运维工作。</li>
<li>方便集中式管理多台服务器。</li>
</ol>


<h3>怎样使用Fabric</h3>

<p>有Python基础的程序员对Fabric一点都不会陌生，因为它就是Python。<br/>
我们先从一个简单的例子开始：</p>

<p>```python fabfile.py
from fabric.api import local</p>

<p>def host_type():</p>

<pre><code>local('uname -s')
</code></pre>

<p><code>
</code>bash</p>

<pre><code>fab host_type
</code></pre>

<p>```</p>

<p>上面例子的便是实用fabric在local环境下执行命令<code>uname</code>，就是这么简单。下面在看一个在remote环境下的操作：</p>

<p>```python fabfile.py
from fabric.api import run</p>

<p>env.user = 'pat'
env.key_filename = '~/.ssh/id_rsa'
env.password = 'patpassword'</p>

<p>def host_type():</p>

<pre><code>run('uname -s')
</code></pre>

<p><code>
</code>bash</p>

<pre><code>fab host_type
</code></pre>

<p>```</p>

<p>注意，这次我们用<code>run</code>代替了<code>local</code>，它的意思是在remote机器上执行某命令。当然，能够从local连接到remote，并且有执行权限才可以执行，这些都是可以在<code>env</code>中指定的。<code>env</code>结论是整个fabric脚本执行中的一个全局变量，<code>env.user</code>，<code>env.key_filename</code>和<code>env.password</code>都是<code>env</code>的保留关键字，分别指明登陆remote的user，密钥以及密码。密钥和密码可以是二选一。密码在使用<code>sudo</code>命令的时候是必须的。<br/>
如果我们想要管理多台remote服务器的时候该怎么做呢？好，我现在开始介绍。<br/>
首先，我需要引入Fabric中的一个概念：<strong>role</strong>。你可以把<strong>role</strong>理解成remote的标识，它可以是一个remote，也可以是一组remotes，通常我们在fabfile中是用<code>env.roledefs</code>来定义的，然后通过指定<code>env.roles</code>来决定使用那一个/组roles。</p>

<p>```python fabfile.py
env.roledefs ={</p>

<pre><code>'local': ['localhost'],
'prd_1': ['192.168.0.100'],
'prd_2': ['192.168.0.101'],
'prd_3': ['192.168.0.102'],
'product': ['192.168.0.100', 
        '192.168.0.101', 
        '192.168.0.102',
        ]
</code></pre>

<p>}</p>

<p>def prd_1():</p>

<pre><code>env.user = 'pat'
env.key_filename = 'xxxx'
env.password = 'patpassword'
env.roles = ['prd1']
</code></pre>

<p>def prd_2():</p>

<pre><code>env.user = 'pat'
env.key_filename = 'xxxx'
env.password = 'patpassword'
env.roles = ['prd2']
</code></pre>

<p>def prd_3():</p>

<pre><code>env.user = 'pat'
env.key_filename = 'xxxxx'
env.password = 'patpassword'
env.roles = ['prd3']
</code></pre>

<p>def product():</p>

<pre><code>env.user = 'pat'
env.key_filename = 'xxxx'
env.password = 'patpassword'
env.roles = ['product']
</code></pre>

<p>def host_type():</p>

<pre><code>run('uname -s')
</code></pre>

<p><code>
</code>bash 调用</p>

<h1>只在prd_1上执行</h1>

<p>fab prd_1 host_type</p>

<h1>只在prd_2上执行</h1>

<p>fab prd_2 host_type</p>

<h1>同时在三台remote上执行</h1>

<p>fab product host_type
```</p>

<p>看到这里，你是否发现其实<code>fab</code>就是在依次执行后面的方法。嗯，其实道理就是这么简单。</p>

<p>现在，你就可以用Fabric进行自己的集群运维管理了。提示一下，下面两个API不多，先好好了解下Fabric都可以做些什么吧：</p>

<ol>
<li><a href="http://docs.fabfile.org/en/1.5/#core-api">Core API</a></li>
<li><a href="http://docs.fabfile.org/en/1.5/#contrib-api">Contrib API</a></li>
<li>提供一个完整的Fabfile做参考：<a href="https://github.com/samuelclay/NewsBlur/blob/master/fabfile.py">fabfile.py</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
